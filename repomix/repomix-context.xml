This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: slides-new/**, talk/outline.md, talk/talk-outline-only.md
- Files matching these patterns are excluded: **/node_modules/**, **/.git/**, **/dist/**, **/build/**, **/.venv/**, **/venv/**, **/*.min.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
slides-new/
  html/
    slide-01.html
    slide-02.html
    slide-03.html
    slide-04.html
    slide-05.html
    slide-06.html
    slide-07.html
    slide-08.html
    slide-09.html
    slide-10.html
    slide-11.html
    slide-12.html
    slide-13.html
    slide-14.html
    slide-15.html
    slide-16.html
    slide-17.html
    slide-18.html
    slide-19.html
    slide-20.html
    slide-21.html
    styles.css
  Agentic-AI-Agent-Talk.pptx
  build.js
  html2pptx.js
  package.json
  README.md
talk/
  outline.md
  talk-outline-only.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="slides-new/html/slide-01.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Title</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Agent Talk</p>
    <h1>Agentic AI for Reproducible Language Science</h1>
    <p class="tagline">From Prompt to Pipeline</p>
  </header>
  <ul class="metric-list">
    <li><p>Shane Lindsay</p></li>
    <li><p>s.lindsay@hull.ac.uk</p></li>
    <li><p>University of Hull</p></li>
    <li><p>github.com/shanelindsay/agentic-r</p></li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-02.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Agenda</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Overview</p>
    <h2>Agenda</h2>
  </header>
  <ul>
    <li>Why agentic AI matters right now</li>
    <li>Defining agents and their toolkit</li>
    <li>Demo: reproducible research with agents</li>
    <li>Patterns and practices you can reuse</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-03.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Prerequisites</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Setting the Stage</p>
    <h2>Pre-requisites</h2>
  </header>
  <ul>
    <li>Familiarity with LLM chatbots such as ChatGPT</li>
    <li>Comfortable with R (ideas apply to Python and beyond)</li>
    <li>Curiosity to explore <span class="emphasis">探索未至之境</span> - discovering what lies ahead</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-04.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Why Now</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Context</p>
    <h2>Why Agents Now</h2>
  </header>
  <ul>
    <li>Latest LLMs handle multi-step, tool-rich workflows</li>
    <li>Usage costs now fit student and lab budgets</li>
    <li>Interfaces are accessible beyond specialist teams</li>
    <li>Agents already boost everyday research output</li>
  </ul>
  <div class="callout">
    <p>Provocation: By the end of 2025 nobody needs to code or launch SPSS ever again.</p>
  </div>
</body>
</html>
</file>

<file path="slides-new/html/slide-05.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - What Is an Agent</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Definitions</p>
    <h2>What Is an Agent?</h2>
  </header>
  <ul>
    <li>A general-purpose LLM embedded in your computing environment</li>
    <li>Reads and writes files, runs bash or PowerShell, calls APIs</li>
    <li>Operates autonomously in scoped windows (approx. 20 minutes)</li>
    <li>Searches, codes, executes, documents - linked into full research loops</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-06.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Costs</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Practicalities</p>
    <h2>What Does It Cost?</h2>
  </header>
  <ul>
    <li>One dial: fast and rough versus slow and precise runs</li>
    <li>Heavy daily use approx. $200 per month</li>
    <li>Moderate schedules approx. $100 per month</li>
    <li>Light exploration approx. $20 per month, plus free starter tiers</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-07.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Landscape</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Ecosystem</p>
    <h2>Example Agent Platforms</h2>
  </header>
  <ul>
    <li><b>US:</b> Codex (OpenAI), Claude Code (Anthropic), Gemini (Google), Cursor, Copilot</li>
    <li><b>China:</b> Kimi K2, Qwen 3, GLM 4.5</li>
    <li><b>Today:</b> Codex leads for capability, Claude Code 4.5 close, GLM or K2 offer best value</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-08.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Promise and Perils</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Trade-offs</p>
    <h2>Promise and Perils</h2>
  </header>
  <div class="two-col">
    <div class="column">
      <h3>Promise</h3>
      <ul>
        <li>Accelerate routine analysis and reporting</li>
        <li>Extend what individuals and small teams can deliver</li>
        <li>Lower activation energy for ambitious workflows</li>
      </ul>
    </div>
    <div class="column">
      <h3>Perils</h3>
      <ul>
        <li>Hallucinations and silent errors still happen</li>
        <li>Risk of diffusing responsibility and losing oversight</li>
        <li>Skill atrophy when agents replace deliberate practice</li>
        <li>New operational complexity and tech debt</li>
      </ul>
    </div>
  </div>
</body>
</html>
</file>

<file path="slides-new/html/slide-09.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Using Agents</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Mindset</p>
    <h2>Working With Agents</h2>
  </header>
  <ul>
    <li>Treat agents like new lab members: eager, fast, occasionally wrong</li>
    <li>Structure projects so someone new can run them end to end</li>
    <li>Document guardrails: approvals, time limits, failure modes</li>
    <li>Invest in project hygiene - structure unlocks reliable automation</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-10.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Reproducibility</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Principles</p>
    <h2>Why Reproducible Research?</h2>
  </header>
  <ul>
    <li>Enable peers to verify findings and build on your work</li>
    <li>Increase transparency, reduce hidden biases</li>
    <li>Spot errors earlier via shared, reviewable workflows</li>
    <li>Preserve institutional knowledge beyond any one researcher</li>
    <li>Align with funder and journal expectations</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-11.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Reproducibility & Agents</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Synergy</p>
    <h2>Agentic AI Loves Reproducibility</h2>
  </header>
  <ul>
    <li>Pipelines document the journey: plan -> execute -> review -> share -> rerun</li>
    <li>Deterministic outputs mean agents can refresh manuscripts safely</li>
    <li>Text-based artefacts make diffing, auditing, and PR review trivial</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-12.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Coding Patterns</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Design Patterns</p>
    <h2>How Code Structure Evolves</h2>
  </header>
  <ul>
    <li><b>Monolithic scripts:</b> fast to start, fragile, opaque when something breaks</li>
    <li><b>Numbered scripts:</b> clearer modularity, easier to rerun sections</li>
    <li><b>Makefile pipelines:</b> explicit dependencies, deterministic outputs - press go to reach the manuscript</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-13.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Containers</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Infrastructure</p>
    <h2>Containers & Predictability</h2>
  </header>
  <ul>
    <li>Containers give every run the same starting point</li>
    <li>Agents are stateless - containerised runs keep them grounded</li>
    <li>If a colleague can run the repo from docs, an agent can too</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-14.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - GitHub</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Collaboration</p>
    <h2>GitHub + Agents</h2>
  </header>
  <ul>
    <li>Version history protects work and surfaces diffs automatically</li>
    <li>Agents operate via CLI; humans can review in IDE or web</li>
    <li>Pull requests keep you in the approval loop</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-15.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Repo Tour</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Case Study</p>
    <h2>Inside agentic-r</h2>
  </header>
  <ul>
    <li><span class="emphasis">AGENTS.md</span> is the handbook for humans and agents</li>
    <li><span class="emphasis">dev/run-in-env.sh</span> wraps R sessions with micromamba</li>
    <li><span class="emphasis">environment.yml</span> pins R version and packages</li>
    <li><span class="emphasis">Makefile</span> sequences scripts for deterministic builds</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-16.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Workflow</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Workflow</p>
    <h2>Pipeline Overview</h2>
  </header>
  <ul>
    <li>Makefile orchestrates <span class="emphasis">01_prepare.R</span> then <span class="emphasis">02_model.R</span></li>
    <li>Data flows <span class="emphasis">raw -> processed -> results/metrics.yml</span></li>
    <li>Quarto report reads results for publication-ready prose</li>
    <li>Agents run everything via the environment wrapper</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-17.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Lexical Decision References</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Example Study</p>
    <h2>Lexical Decision in Chinese</h2>
  </header>
  <ul>
    <li>Wang et al. (2025) Simplified Chinese Lexicon Project. <i>Behavior Research Methods</i>.</li>
    <li>Sun et al. (2018) Chinese Lexical Database. <i>Behavior Research Methods</i>.</li>
  </ul>
  <div class="summary">
    <p>Agents start by running the baseline pipeline to reproduce <span class="emphasis">results/metrics.yml</span>.</p>
  </div>
</body>
</html>
</file>

<file path="slides-new/html/slide-18.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Demo Builder</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Agent Demo</p>
    <h2>Builder Pattern</h2>
  </header>
  <ul>
    <li>Prompt: add a predictor and rerun the report</li>
    <li>Agent invokes wrapper scripts and Makefile targets</li>
    <li>Pipeline regenerates outputs and report in minutes</li>
    <li>Diff showcases exactly what changed</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-19.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Demo Review</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Agent Demo</p>
    <h2>Pull Request Review</h2>
  </header>
  <ul>
    <li>A second agent reads the diff and writes a review</li>
    <li>Human reviews the agent's comments and approves or requests changes</li>
    <li>Iterative loop maintains velocity and oversight</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-20.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Patterns</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Playbook</p>
    <h2>Agent Patterns to Copy</h2>
  </header>
  <ul>
    <li><b>Builder:</b> proposes and implements code changes</li>
    <li><b>Checker:</b> audits diffs, reruns tests, validates outputs</li>
    <li><b>Critic:</b> recommends diagnostics or tests when needed</li>
    <li><b>Human:</b> remains final approver and ethical backstop</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/slide-21.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Agent Talk - Where to Start</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <p class="section-label">Next Steps</p>
    <h2>Where to Start</h2>
  </header>
  <ul>
    <li>Pick one pipeline stage - cleaning, modelling, or reporting - and script it</li>
    <li>Keep tasks atomic so agents (and collaborators) can slot in</li>
    <li>Track outputs in version control for transparent reviews</li>
  </ul>
</body>
</html>
</file>

<file path="slides-new/html/styles.css">
:root {
  --bg: #fcfcfc;
  --primary: #b165fb;
  --secondary: #40695b;
  --text: #182d3c;
  --muted: #4a5a68;
}

body {
  margin: 0;
  padding: 56px 72px 64px;
  width: 960px;
  height: 540px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  gap: 18px;
  background-color: var(--bg);
  color: var(--text);
  font-family: 'Trebuchet MS', Arial, sans-serif;
  box-sizing: border-box;
}

header {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

h1, h2, h3 {
  margin: 0;
  font-weight: bold;
  color: var(--primary);
}

h1 {
  font-size: 44px;
}

h2 {
  font-size: 34px;
}

h3 {
  font-size: 26px;
  color: var(--secondary);
}

p {
  margin: 0;
  font-size: 22px;
  line-height: 1.35;
}

ul {
  margin: 0;
  padding-left: 26px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  font-size: 22px;
  line-height: 1.3;
}

li {
  margin: 0;
}

.emphasis {
  color: var(--secondary);
}

.callout {
  background-color: #e9f5f0;
  border-left: 6px solid var(--secondary);
  padding: 18px 20px;
  border-radius: 14px;
}

.callout p {
  font-size: 24px;
  color: var(--secondary);
  font-weight: bold;
}

footer p {
  font-size: 18px;
  color: var(--muted);
}

.two-col {
  display: flex;
  gap: 36px;
  margin-top: 8px;
}

.column {
  flex: 1;
  background-color: #f2ebfd;
  border-radius: 16px;
  padding: 18px 20px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  box-sizing: border-box;
}

.column h3 {
  color: var(--secondary);
  font-size: 24px;
}

.column ul {
  gap: 8px;
  font-size: 21px;
}

.tagline {
  font-size: 20px;
  color: var(--muted);
}

.metric-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.metric-list li {
  list-style-type: none;
  background-color: #f2ebfd;
  border-radius: 14px;
  padding: 14px 18px;
  border-left: 6px solid var(--primary);
}

.metric-list li p {
  font-size: 20px;
  line-height: 1.25;
  color: var(--text);
}

.section-label {
  font-size: 18px;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--muted);
}

.summary {
  background-color: #fbefff;
  border-radius: 16px;
  padding: 18px 20px;
}

.summary ul {
  gap: 12px;
}

.summary p {
  font-size: 22px;
}

.small {
  font-size: 18px;
}
</file>

<file path="slides-new/build.js">
const fs = require('fs');
const path = require('path');
const PptxGenJS = require('pptxgenjs');
const html2pptx = require('./html2pptx');

async function buildDeck() {
  const deck = new PptxGenJS();
  deck.layout = 'LAYOUT_16x9';
  deck.author = 'Shane Lindsay';
  deck.company = 'University of Hull';
  deck.title = 'Agentic AI for Reproducible Language Science';
  deck.subject = 'Agent Talk';

  const slidesDir = path.join(__dirname, 'html');
  const slideFiles = fs
    .readdirSync(slidesDir)
    .filter((file) => file.endsWith('.html'))
    .sort();

  for (const file of slideFiles) {
    const slidePath = path.join(slidesDir, file);
    await html2pptx(slidePath, deck);
  }

  const outputPath = path.join(__dirname, 'Agentic-AI-Agent-Talk.pptx');
  await deck.writeFile({ fileName: outputPath });
  console.log(`Created ${outputPath}`);
}

buildDeck().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
</file>

<file path="slides-new/html2pptx.js">
/**
 * html2pptx - Convert HTML slide to pptxgenjs slide with positioned elements
 *
 * USAGE:
 *   const pptx = new pptxgen();
 *   pptx.layout = 'LAYOUT_16x9';  // Must match HTML body dimensions
 *
 *   const { slide, placeholders } = await html2pptx('slide.html', pptx);
 *   slide.addChart(pptx.charts.LINE, data, placeholders[0]);
 *
 *   await pptx.writeFile('output.pptx');
 *
 * FEATURES:
 *   - Converts HTML to PowerPoint with accurate positioning
 *   - Supports text, images, shapes, and bullet lists
 *   - Extracts placeholder elements (class="placeholder") with positions
 *   - Handles CSS gradients, borders, and margins
 *
 * VALIDATION:
 *   - Uses body width/height from HTML for viewport sizing
 *   - Throws error if HTML dimensions don't match presentation layout
 *   - Throws error if content overflows body (with overflow details)
 *
 * RETURNS:
 *   { slide, placeholders } where placeholders is an array of { id, x, y, w, h }
 */

const { chromium } = require('playwright');
const path = require('path');
const sharp = require('sharp');

const PT_PER_PX = 0.75;
const PX_PER_IN = 96;
const EMU_PER_IN = 914400;

// Helper: Get body dimensions and check for overflow
async function getBodyDimensions(page) {
  const bodyDimensions = await page.evaluate(() => {
    const body = document.body;
    const style = window.getComputedStyle(body);

    return {
      width: parseFloat(style.width),
      height: parseFloat(style.height),
      scrollWidth: body.scrollWidth,
      scrollHeight: body.scrollHeight
    };
  });

  const errors = [];
  const widthOverflowPx = Math.max(0, bodyDimensions.scrollWidth - bodyDimensions.width - 1);
  const heightOverflowPx = Math.max(0, bodyDimensions.scrollHeight - bodyDimensions.height - 1);

  const widthOverflowPt = widthOverflowPx * PT_PER_PX;
  const heightOverflowPt = heightOverflowPx * PT_PER_PX;

  if (widthOverflowPt > 0 || heightOverflowPt > 0) {
    const directions = [];
    if (widthOverflowPt > 0) directions.push(`${widthOverflowPt.toFixed(1)}pt horizontally`);
    if (heightOverflowPt > 0) directions.push(`${heightOverflowPt.toFixed(1)}pt vertically`);
    const reminder = heightOverflowPt > 0 ? ' (Remember: leave 0.5" margin at bottom of slide)' : '';
    errors.push(`HTML content overflows body by ${directions.join(' and ')}${reminder}`);
  }

  return { ...bodyDimensions, errors };
}

// Helper: Validate dimensions match presentation layout
function validateDimensions(bodyDimensions, pres) {
  const errors = [];
  const widthInches = bodyDimensions.width / PX_PER_IN;
  const heightInches = bodyDimensions.height / PX_PER_IN;

  if (pres.presLayout) {
    const layoutWidth = pres.presLayout.width / EMU_PER_IN;
    const layoutHeight = pres.presLayout.height / EMU_PER_IN;

    if (Math.abs(layoutWidth - widthInches) > 0.1 || Math.abs(layoutHeight - heightInches) > 0.1) {
      errors.push(
        `HTML dimensions (${widthInches.toFixed(1)}" × ${heightInches.toFixed(1)}") ` +
        `don't match presentation layout (${layoutWidth.toFixed(1)}" × ${layoutHeight.toFixed(1)}")`
      );
    }
  }
  return errors;
}

function validateTextBoxPosition(slideData, bodyDimensions) {
  const errors = [];
  const slideHeightInches = bodyDimensions.height / PX_PER_IN;
  const minBottomMargin = 0.5; // 0.5 inches from bottom

  for (const el of slideData.elements) {
    // Check text elements (p, h1-h6, list)
    if (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'list'].includes(el.type)) {
      const fontSize = el.style?.fontSize || 0;
      const bottomEdge = el.position.y + el.position.h;
      const distanceFromBottom = slideHeightInches - bottomEdge;

      if (fontSize > 12 && distanceFromBottom < minBottomMargin) {
        const getText = () => {
          if (typeof el.text === 'string') return el.text;
          if (Array.isArray(el.text)) return el.text.find(t => t.text)?.text || '';
          if (Array.isArray(el.items)) return el.items.find(item => item.text)?.text || '';
          return '';
        };
        const textPrefix = getText().substring(0, 50) + (getText().length > 50 ? '...' : '');

        errors.push(
          `Text box "${textPrefix}" ends too close to bottom edge ` +
          `(${distanceFromBottom.toFixed(2)}" from bottom, minimum ${minBottomMargin}" required)`
        );
      }
    }
  }

  return errors;
}

// Helper: Add background to slide
async function addBackground(slideData, targetSlide, tmpDir) {
  if (slideData.background.type === 'image' && slideData.background.path) {
    let imagePath = slideData.background.path.startsWith('file://')
      ? slideData.background.path.replace('file://', '')
      : slideData.background.path;
    targetSlide.background = { path: imagePath };
  } else if (slideData.background.type === 'color' && slideData.background.value) {
    targetSlide.background = { color: slideData.background.value };
  }
}

// Helper: Add elements to slide
function addElements(slideData, targetSlide, pres) {
  for (const el of slideData.elements) {
    if (el.type === 'image') {
      let imagePath = el.src.startsWith('file://') ? el.src.replace('file://', '') : el.src;
      targetSlide.addImage({
        path: imagePath,
        x: el.position.x,
        y: el.position.y,
        w: el.position.w,
        h: el.position.h
      });
    } else if (el.type === 'line') {
      targetSlide.addShape(pres.ShapeType.line, {
        x: el.x1,
        y: el.y1,
        w: el.x2 - el.x1,
        h: el.y2 - el.y1,
        line: { color: el.color, width: el.width }
      });
    } else if (el.type === 'shape') {
      const shapeOptions = {
        x: el.position.x,
        y: el.position.y,
        w: el.position.w,
        h: el.position.h,
        shape: el.shape.rectRadius > 0 ? pres.ShapeType.roundRect : pres.ShapeType.rect
      };

      if (el.shape.fill) {
        shapeOptions.fill = { color: el.shape.fill };
        if (el.shape.transparency != null) shapeOptions.fill.transparency = el.shape.transparency;
      }
      if (el.shape.line) shapeOptions.line = el.shape.line;
      if (el.shape.rectRadius > 0) shapeOptions.rectRadius = el.shape.rectRadius;
      if (el.shape.shadow) shapeOptions.shadow = el.shape.shadow;

      targetSlide.addText(el.text || '', shapeOptions);
    } else if (el.type === 'list') {
      const listOptions = {
        x: el.position.x,
        y: el.position.y,
        w: el.position.w,
        h: el.position.h,
        fontSize: el.style.fontSize,
        fontFace: el.style.fontFace,
        color: el.style.color,
        align: el.style.align,
        valign: 'top',
        lineSpacing: el.style.lineSpacing,
        paraSpaceBefore: el.style.paraSpaceBefore,
        paraSpaceAfter: el.style.paraSpaceAfter,
        margin: el.style.margin
      };
      if (el.style.margin) listOptions.margin = el.style.margin;
      targetSlide.addText(el.items, listOptions);
    } else {
      // Check if text is single-line (height suggests one line)
      const lineHeight = el.style.lineSpacing || el.style.fontSize * 1.2;
      const isSingleLine = el.position.h <= lineHeight * 1.5;

      let adjustedX = el.position.x;
      let adjustedW = el.position.w;

      // Make single-line text 2% wider to account for underestimate
      if (isSingleLine) {
        const widthIncrease = el.position.w * 0.02;
        const align = el.style.align;

        if (align === 'center') {
          // Center: expand both sides
          adjustedX = el.position.x - (widthIncrease / 2);
          adjustedW = el.position.w + widthIncrease;
        } else if (align === 'right') {
          // Right: expand to the left
          adjustedX = el.position.x - widthIncrease;
          adjustedW = el.position.w + widthIncrease;
        } else {
          // Left (default): expand to the right
          adjustedW = el.position.w + widthIncrease;
        }
      }

      const textOptions = {
        x: adjustedX,
        y: el.position.y,
        w: adjustedW,
        h: el.position.h,
        fontSize: el.style.fontSize,
        fontFace: el.style.fontFace,
        color: el.style.color,
        bold: el.style.bold,
        italic: el.style.italic,
        underline: el.style.underline,
        valign: 'top',
        lineSpacing: el.style.lineSpacing,
        paraSpaceBefore: el.style.paraSpaceBefore,
        paraSpaceAfter: el.style.paraSpaceAfter,
        inset: 0  // Remove default PowerPoint internal padding
      };

      if (el.style.align) textOptions.align = el.style.align;
      if (el.style.margin) textOptions.margin = el.style.margin;
      if (el.style.rotate !== undefined) textOptions.rotate = el.style.rotate;
      if (el.style.transparency !== null && el.style.transparency !== undefined) textOptions.transparency = el.style.transparency;

      targetSlide.addText(el.text, textOptions);
    }
  }
}

// Helper: Extract slide data from HTML page
async function extractSlideData(page) {
  return await page.evaluate(() => {
    const PT_PER_PX = 0.75;
    const PX_PER_IN = 96;

    // Fonts that are single-weight and should not have bold applied
    // (applying bold causes PowerPoint to use faux bold which makes text wider)
    const SINGLE_WEIGHT_FONTS = ['impact'];

    // Helper: Check if a font should skip bold formatting
    const shouldSkipBold = (fontFamily) => {
      if (!fontFamily) return false;
      const normalizedFont = fontFamily.toLowerCase().replace(/['"]/g, '').split(',')[0].trim();
      return SINGLE_WEIGHT_FONTS.includes(normalizedFont);
    };

    // Unit conversion helpers
    const pxToInch = (px) => px / PX_PER_IN;
    const pxToPoints = (pxStr) => parseFloat(pxStr) * PT_PER_PX;
    const rgbToHex = (rgbStr) => {
      // Handle transparent backgrounds by defaulting to white
      if (rgbStr === 'rgba(0, 0, 0, 0)' || rgbStr === 'transparent') return 'FFFFFF';

      const match = rgbStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!match) return 'FFFFFF';
      return match.slice(1).map(n => parseInt(n).toString(16).padStart(2, '0')).join('');
    };

    const extractAlpha = (rgbStr) => {
      const match = rgbStr.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
      if (!match || !match[4]) return null;
      const alpha = parseFloat(match[4]);
      return Math.round((1 - alpha) * 100);
    };

    const applyTextTransform = (text, textTransform) => {
      if (textTransform === 'uppercase') return text.toUpperCase();
      if (textTransform === 'lowercase') return text.toLowerCase();
      if (textTransform === 'capitalize') {
        return text.replace(/\b\w/g, c => c.toUpperCase());
      }
      return text;
    };

    // Extract rotation angle from CSS transform and writing-mode
    const getRotation = (transform, writingMode) => {
      let angle = 0;

      // Handle writing-mode first
      // PowerPoint: 90° = text rotated 90° clockwise (reads top to bottom, letters upright)
      // PowerPoint: 270° = text rotated 270° clockwise (reads bottom to top, letters upright)
      if (writingMode === 'vertical-rl') {
        // vertical-rl alone = text reads top to bottom = 90° in PowerPoint
        angle = 90;
      } else if (writingMode === 'vertical-lr') {
        // vertical-lr alone = text reads bottom to top = 270° in PowerPoint
        angle = 270;
      }

      // Then add any transform rotation
      if (transform && transform !== 'none') {
        // Try to match rotate() function
        const rotateMatch = transform.match(/rotate\((-?\d+(?:\.\d+)?)deg\)/);
        if (rotateMatch) {
          angle += parseFloat(rotateMatch[1]);
        } else {
          // Browser may compute as matrix - extract rotation from matrix
          const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
          if (matrixMatch) {
            const values = matrixMatch[1].split(',').map(parseFloat);
            // matrix(a, b, c, d, e, f) where rotation = atan2(b, a)
            const matrixAngle = Math.atan2(values[1], values[0]) * (180 / Math.PI);
            angle += Math.round(matrixAngle);
          }
        }
      }

      // Normalize to 0-359 range
      angle = angle % 360;
      if (angle < 0) angle += 360;

      return angle === 0 ? null : angle;
    };

    // Get position/dimensions accounting for rotation
    const getPositionAndSize = (el, rect, rotation) => {
      if (rotation === null) {
        return { x: rect.left, y: rect.top, w: rect.width, h: rect.height };
      }

      // For 90° or 270° rotations, swap width and height
      // because PowerPoint applies rotation to the original (unrotated) box
      const isVertical = rotation === 90 || rotation === 270;

      if (isVertical) {
        // The browser shows us the rotated dimensions (tall box for vertical text)
        // But PowerPoint needs the pre-rotation dimensions (wide box that will be rotated)
        // So we swap: browser's height becomes PPT's width, browser's width becomes PPT's height
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        return {
          x: centerX - rect.height / 2,
          y: centerY - rect.width / 2,
          w: rect.height,
          h: rect.width
        };
      }

      // For other rotations, use element's offset dimensions
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      return {
        x: centerX - el.offsetWidth / 2,
        y: centerY - el.offsetHeight / 2,
        w: el.offsetWidth,
        h: el.offsetHeight
      };
    };

    // Parse CSS box-shadow into PptxGenJS shadow properties
    const parseBoxShadow = (boxShadow) => {
      if (!boxShadow || boxShadow === 'none') return null;

      // Browser computed style format: "rgba(0, 0, 0, 0.3) 2px 2px 8px 0px [inset]"
      // CSS format: "[inset] 2px 2px 8px 0px rgba(0, 0, 0, 0.3)"

      const insetMatch = boxShadow.match(/inset/);

      // IMPORTANT: PptxGenJS/PowerPoint doesn't properly support inset shadows
      // Only process outer shadows to avoid file corruption
      if (insetMatch) return null;

      // Extract color first (rgba or rgb at start)
      const colorMatch = boxShadow.match(/rgba?\([^)]+\)/);

      // Extract numeric values (handles both px and pt units)
      const parts = boxShadow.match(/([-\d.]+)(px|pt)/g);

      if (!parts || parts.length < 2) return null;

      const offsetX = parseFloat(parts[0]);
      const offsetY = parseFloat(parts[1]);
      const blur = parts.length > 2 ? parseFloat(parts[2]) : 0;

      // Calculate angle from offsets (in degrees, 0 = right, 90 = down)
      let angle = 0;
      if (offsetX !== 0 || offsetY !== 0) {
        angle = Math.atan2(offsetY, offsetX) * (180 / Math.PI);
        if (angle < 0) angle += 360;
      }

      // Calculate offset distance (hypotenuse)
      const offset = Math.sqrt(offsetX * offsetX + offsetY * offsetY) * PT_PER_PX;

      // Extract opacity from rgba
      let opacity = 0.5;
      if (colorMatch) {
        const opacityMatch = colorMatch[0].match(/[\d.]+\)$/);
        if (opacityMatch) {
          opacity = parseFloat(opacityMatch[0].replace(')', ''));
        }
      }

      return {
        type: 'outer',
        angle: Math.round(angle),
        blur: blur * 0.75, // Convert to points
        color: colorMatch ? rgbToHex(colorMatch[0]) : '000000',
        offset: offset,
        opacity
      };
    };

    // Parse inline formatting tags (<b>, <i>, <u>, <strong>, <em>, <span>) into text runs
    const parseInlineFormatting = (element, baseOptions = {}, runs = [], baseTextTransform = (x) => x) => {
      let prevNodeIsText = false;

      element.childNodes.forEach((node) => {
        let textTransform = baseTextTransform;

        const isText = node.nodeType === Node.TEXT_NODE || node.tagName === 'BR';
        if (isText) {
          const text = node.tagName === 'BR' ? '\n' : textTransform(node.textContent.replace(/\s+/g, ' '));
          const prevRun = runs[runs.length - 1];
          if (prevNodeIsText && prevRun) {
            prevRun.text += text;
          } else {
            runs.push({ text, options: { ...baseOptions } });
          }

        } else if (node.nodeType === Node.ELEMENT_NODE && node.textContent.trim()) {
          const options = { ...baseOptions };
          const computed = window.getComputedStyle(node);

          // Handle inline elements with computed styles
          if (node.tagName === 'SPAN' || node.tagName === 'B' || node.tagName === 'STRONG' || node.tagName === 'I' || node.tagName === 'EM' || node.tagName === 'U') {
            const isBold = computed.fontWeight === 'bold' || parseInt(computed.fontWeight) >= 600;
            if (isBold && !shouldSkipBold(computed.fontFamily)) options.bold = true;
            if (computed.fontStyle === 'italic') options.italic = true;
            if (computed.textDecoration && computed.textDecoration.includes('underline')) options.underline = true;
            if (computed.color && computed.color !== 'rgb(0, 0, 0)') {
              options.color = rgbToHex(computed.color);
              const transparency = extractAlpha(computed.color);
              if (transparency !== null) options.transparency = transparency;
            }
            if (computed.fontSize) options.fontSize = pxToPoints(computed.fontSize);

            // Apply text-transform on the span element itself
            if (computed.textTransform && computed.textTransform !== 'none') {
              const transformStr = computed.textTransform;
              textTransform = (text) => applyTextTransform(text, transformStr);
            }

            // Validate: Check for margins on inline elements
            if (computed.marginLeft && parseFloat(computed.marginLeft) > 0) {
              errors.push(`Inline element <${node.tagName.toLowerCase()}> has margin-left which is not supported in PowerPoint. Remove margin from inline elements.`);
            }
            if (computed.marginRight && parseFloat(computed.marginRight) > 0) {
              errors.push(`Inline element <${node.tagName.toLowerCase()}> has margin-right which is not supported in PowerPoint. Remove margin from inline elements.`);
            }
            if (computed.marginTop && parseFloat(computed.marginTop) > 0) {
              errors.push(`Inline element <${node.tagName.toLowerCase()}> has margin-top which is not supported in PowerPoint. Remove margin from inline elements.`);
            }
            if (computed.marginBottom && parseFloat(computed.marginBottom) > 0) {
              errors.push(`Inline element <${node.tagName.toLowerCase()}> has margin-bottom which is not supported in PowerPoint. Remove margin from inline elements.`);
            }

            // Recursively process the child node. This will flatten nested spans into multiple runs.
            parseInlineFormatting(node, options, runs, textTransform);
          }
        }

        prevNodeIsText = isText;
      });

      // Trim leading space from first run and trailing space from last run
      if (runs.length > 0) {
        runs[0].text = runs[0].text.replace(/^\s+/, '');
        runs[runs.length - 1].text = runs[runs.length - 1].text.replace(/\s+$/, '');
      }

      return runs.filter(r => r.text.length > 0);
    };

    // Extract background from body (image or color)
    const body = document.body;
    const bodyStyle = window.getComputedStyle(body);
    const bgImage = bodyStyle.backgroundImage;
    const bgColor = bodyStyle.backgroundColor;

    // Collect validation errors
    const errors = [];

    // Validate: Check for CSS gradients
    if (bgImage && (bgImage.includes('linear-gradient') || bgImage.includes('radial-gradient'))) {
      errors.push(
        'CSS gradients are not supported. Use Sharp to rasterize gradients as PNG images first, ' +
        'then reference with background-image: url(\'gradient.png\')'
      );
    }

    let background;
    if (bgImage && bgImage !== 'none') {
      // Extract URL from url("...") or url(...)
      const urlMatch = bgImage.match(/url\(["']?([^"')]+)["']?\)/);
      if (urlMatch) {
        background = {
          type: 'image',
          path: urlMatch[1]
        };
      } else {
        background = {
          type: 'color',
          value: rgbToHex(bgColor)
        };
      }
    } else {
      background = {
        type: 'color',
        value: rgbToHex(bgColor)
      };
    }

    // Process all elements
    const elements = [];
    const placeholders = [];
    const textTags = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'UL', 'OL', 'LI'];
    const processed = new Set();

    document.querySelectorAll('*').forEach((el) => {
      if (processed.has(el)) return;

      // Validate text elements don't have backgrounds, borders, or shadows
      if (textTags.includes(el.tagName)) {
        const computed = window.getComputedStyle(el);
        const hasBg = computed.backgroundColor && computed.backgroundColor !== 'rgba(0, 0, 0, 0)';
        const hasBorder = (computed.borderWidth && parseFloat(computed.borderWidth) > 0) ||
                          (computed.borderTopWidth && parseFloat(computed.borderTopWidth) > 0) ||
                          (computed.borderRightWidth && parseFloat(computed.borderRightWidth) > 0) ||
                          (computed.borderBottomWidth && parseFloat(computed.borderBottomWidth) > 0) ||
                          (computed.borderLeftWidth && parseFloat(computed.borderLeftWidth) > 0);
        const hasShadow = computed.boxShadow && computed.boxShadow !== 'none';

        if (hasBg || hasBorder || hasShadow) {
          errors.push(
            `Text element <${el.tagName.toLowerCase()}> has ${hasBg ? 'background' : hasBorder ? 'border' : 'shadow'}. ` +
            'Backgrounds, borders, and shadows are only supported on <div> elements, not text elements.'
          );
          return;
        }
      }

      // Extract placeholder elements (for charts, etc.)
      if (el.className && el.className.includes('placeholder')) {
        const rect = el.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          errors.push(
            `Placeholder "${el.id || 'unnamed'}" has ${rect.width === 0 ? 'width: 0' : 'height: 0'}. Check the layout CSS.`
          );
        } else {
          placeholders.push({
            id: el.id || `placeholder-${placeholders.length}`,
            x: pxToInch(rect.left),
            y: pxToInch(rect.top),
            w: pxToInch(rect.width),
            h: pxToInch(rect.height)
          });
        }
        processed.add(el);
        return;
      }

      // Extract images
      if (el.tagName === 'IMG') {
        const rect = el.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          elements.push({
            type: 'image',
            src: el.src,
            position: {
              x: pxToInch(rect.left),
              y: pxToInch(rect.top),
              w: pxToInch(rect.width),
              h: pxToInch(rect.height)
            }
          });
          processed.add(el);
          return;
        }
      }

      // Extract DIVs with backgrounds/borders as shapes
      const isContainer = el.tagName === 'DIV' && !textTags.includes(el.tagName);
      if (isContainer) {
        const computed = window.getComputedStyle(el);
        const hasBg = computed.backgroundColor && computed.backgroundColor !== 'rgba(0, 0, 0, 0)';

        // Validate: Check for unwrapped text content in DIV
        for (const node of el.childNodes) {
          if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent.trim();
            if (text) {
              errors.push(
                `DIV element contains unwrapped text "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}". ` +
                'All text must be wrapped in <p>, <h1>-<h6>, <ul>, or <ol> tags to appear in PowerPoint.'
              );
            }
          }
        }

        // Check for background images on shapes
        const bgImage = computed.backgroundImage;
        if (bgImage && bgImage !== 'none') {
          errors.push(
            'Background images on DIV elements are not supported. ' +
            'Use solid colors or borders for shapes, or use slide.addImage() in PptxGenJS to layer images.'
          );
          return;
        }

        // Check for borders - both uniform and partial
        const borderTop = computed.borderTopWidth;
        const borderRight = computed.borderRightWidth;
        const borderBottom = computed.borderBottomWidth;
        const borderLeft = computed.borderLeftWidth;
        const borders = [borderTop, borderRight, borderBottom, borderLeft].map(b => parseFloat(b) || 0);
        const hasBorder = borders.some(b => b > 0);
        const hasUniformBorder = hasBorder && borders.every(b => b === borders[0]);
        const borderLines = [];

        if (hasBorder && !hasUniformBorder) {
          const rect = el.getBoundingClientRect();
          const x = pxToInch(rect.left);
          const y = pxToInch(rect.top);
          const w = pxToInch(rect.width);
          const h = pxToInch(rect.height);

          // Collect lines to add after shape (inset by half the line width to center on edge)
          if (parseFloat(borderTop) > 0) {
            const widthPt = pxToPoints(borderTop);
            const inset = (widthPt / 72) / 2; // Convert points to inches, then half
            borderLines.push({
              type: 'line',
              x1: x, y1: y + inset, x2: x + w, y2: y + inset,
              width: widthPt,
              color: rgbToHex(computed.borderTopColor)
            });
          }
          if (parseFloat(borderRight) > 0) {
            const widthPt = pxToPoints(borderRight);
            const inset = (widthPt / 72) / 2;
            borderLines.push({
              type: 'line',
              x1: x + w - inset, y1: y, x2: x + w - inset, y2: y + h,
              width: widthPt,
              color: rgbToHex(computed.borderRightColor)
            });
          }
          if (parseFloat(borderBottom) > 0) {
            const widthPt = pxToPoints(borderBottom);
            const inset = (widthPt / 72) / 2;
            borderLines.push({
              type: 'line',
              x1: x, y1: y + h - inset, x2: x + w, y2: y + h - inset,
              width: widthPt,
              color: rgbToHex(computed.borderBottomColor)
            });
          }
          if (parseFloat(borderLeft) > 0) {
            const widthPt = pxToPoints(borderLeft);
            const inset = (widthPt / 72) / 2;
            borderLines.push({
              type: 'line',
              x1: x + inset, y1: y, x2: x + inset, y2: y + h,
              width: widthPt,
              color: rgbToHex(computed.borderLeftColor)
            });
          }
        }

        if (hasBg || hasBorder) {
          const rect = el.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            const shadow = parseBoxShadow(computed.boxShadow);

            // Only add shape if there's background or uniform border
            if (hasBg || hasUniformBorder) {
              elements.push({
                type: 'shape',
                text: '',  // Shape only - child text elements render on top
                position: {
                  x: pxToInch(rect.left),
                  y: pxToInch(rect.top),
                  w: pxToInch(rect.width),
                  h: pxToInch(rect.height)
                },
                shape: {
                  fill: hasBg ? rgbToHex(computed.backgroundColor) : null,
                  transparency: hasBg ? extractAlpha(computed.backgroundColor) : null,
                  line: hasUniformBorder ? {
                    color: rgbToHex(computed.borderColor),
                    width: pxToPoints(computed.borderWidth)
                  } : null,
                  // Convert border-radius to rectRadius (in inches)
                  // % values: 50%+ = circle (1), <50% = percentage of min dimension
                  // pt values: divide by 72 (72pt = 1 inch)
                  // px values: divide by 96 (96px = 1 inch)
                  rectRadius: (() => {
                    const radius = computed.borderRadius;
                    const radiusValue = parseFloat(radius);
                    if (radiusValue === 0) return 0;

                    if (radius.includes('%')) {
                      if (radiusValue >= 50) return 1;
                      // Calculate percentage of smaller dimension
                      const minDim = Math.min(rect.width, rect.height);
                      return (radiusValue / 100) * pxToInch(minDim);
                    }

                    if (radius.includes('pt')) return radiusValue / 72;
                    return radiusValue / PX_PER_IN;
                  })(),
                  shadow: shadow
                }
              });
            }

            // Add partial border lines
            elements.push(...borderLines);

            processed.add(el);
            return;
          }
        }
      }

      // Extract bullet lists as single text block
      if (el.tagName === 'UL' || el.tagName === 'OL') {
        const rect = el.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return;

        const liElements = Array.from(el.querySelectorAll('li'));
        const items = [];
        const ulComputed = window.getComputedStyle(el);
        const ulPaddingLeftPt = pxToPoints(ulComputed.paddingLeft);

        // Split: margin-left for bullet position, indent for text position
        // margin-left + indent = ul padding-left
        const marginLeft = ulPaddingLeftPt * 0.5;
        const textIndent = ulPaddingLeftPt * 0.5;

        liElements.forEach((li, idx) => {
          const isLast = idx === liElements.length - 1;
          const runs = parseInlineFormatting(li, { breakLine: false });
          // Clean manual bullets from first run
          if (runs.length > 0) {
            runs[0].text = runs[0].text.replace(/^[•\-\*▪▸]\s*/, '');
            runs[0].options.bullet = { indent: textIndent };
          }
          // Set breakLine on last run
          if (runs.length > 0 && !isLast) {
            runs[runs.length - 1].options.breakLine = true;
          }
          items.push(...runs);
        });

        const computed = window.getComputedStyle(liElements[0] || el);

        elements.push({
          type: 'list',
          items: items,
          position: {
            x: pxToInch(rect.left),
            y: pxToInch(rect.top),
            w: pxToInch(rect.width),
            h: pxToInch(rect.height)
          },
          style: {
            fontSize: pxToPoints(computed.fontSize),
            fontFace: computed.fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
            color: rgbToHex(computed.color),
            transparency: extractAlpha(computed.color),
            align: computed.textAlign === 'start' ? 'left' : computed.textAlign,
            lineSpacing: computed.lineHeight && computed.lineHeight !== 'normal' ? pxToPoints(computed.lineHeight) : null,
            paraSpaceBefore: 0,
            paraSpaceAfter: pxToPoints(computed.marginBottom),
            // PptxGenJS margin array is [left, right, bottom, top]
            margin: [marginLeft, 0, 0, 0]
          }
        });

        liElements.forEach(li => processed.add(li));
        processed.add(el);
        return;
      }

      // Extract text elements (P, H1, H2, etc.)
      if (!textTags.includes(el.tagName)) return;

      const rect = el.getBoundingClientRect();
      const text = el.textContent.trim();
      if (rect.width === 0 || rect.height === 0 || !text) return;

      // Validate: Check for manual bullet symbols in text elements (not in lists)
      if (el.tagName !== 'LI' && /^[•\-\*▪▸○●◆◇■□]\s/.test(text.trimStart())) {
        errors.push(
          `Text element <${el.tagName.toLowerCase()}> starts with bullet symbol "${text.substring(0, 20)}...". ` +
          'Use <ul> or <ol> lists instead of manual bullet symbols.'
        );
        return;
      }

      const computed = window.getComputedStyle(el);
      const rotation = getRotation(computed.transform, computed.writingMode);
      const { x, y, w, h } = getPositionAndSize(el, rect, rotation);

      const baseStyle = {
        fontSize: pxToPoints(computed.fontSize),
        fontFace: computed.fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
        color: rgbToHex(computed.color),
        align: computed.textAlign === 'start' ? 'left' : computed.textAlign,
        lineSpacing: pxToPoints(computed.lineHeight),
        paraSpaceBefore: pxToPoints(computed.marginTop),
        paraSpaceAfter: pxToPoints(computed.marginBottom),
        // PptxGenJS margin array is [left, right, bottom, top] (not [top, right, bottom, left] as documented)
        margin: [
          pxToPoints(computed.paddingLeft),
          pxToPoints(computed.paddingRight),
          pxToPoints(computed.paddingBottom),
          pxToPoints(computed.paddingTop)
        ]
      };

      const transparency = extractAlpha(computed.color);
      if (transparency !== null) baseStyle.transparency = transparency;

      if (rotation !== null) baseStyle.rotate = rotation;

      const hasFormatting = el.querySelector('b, i, u, strong, em, span, br');

      if (hasFormatting) {
        // Text with inline formatting
        const transformStr = computed.textTransform;
        const runs = parseInlineFormatting(el, {}, [], (str) => applyTextTransform(str, transformStr));

        // Adjust lineSpacing based on largest fontSize in runs
        const adjustedStyle = { ...baseStyle };
        if (adjustedStyle.lineSpacing) {
          const maxFontSize = Math.max(
            adjustedStyle.fontSize,
            ...runs.map(r => r.options?.fontSize || 0)
          );
          if (maxFontSize > adjustedStyle.fontSize) {
            const lineHeightMultiplier = adjustedStyle.lineSpacing / adjustedStyle.fontSize;
            adjustedStyle.lineSpacing = maxFontSize * lineHeightMultiplier;
          }
        }

        elements.push({
          type: el.tagName.toLowerCase(),
          text: runs,
          position: { x: pxToInch(x), y: pxToInch(y), w: pxToInch(w), h: pxToInch(h) },
          style: adjustedStyle
        });
      } else {
        // Plain text - inherit CSS formatting
        const textTransform = computed.textTransform;
        const transformedText = applyTextTransform(text, textTransform);

        const isBold = computed.fontWeight === 'bold' || parseInt(computed.fontWeight) >= 600;

        elements.push({
          type: el.tagName.toLowerCase(),
          text: transformedText,
          position: { x: pxToInch(x), y: pxToInch(y), w: pxToInch(w), h: pxToInch(h) },
          style: {
            ...baseStyle,
            bold: isBold && !shouldSkipBold(computed.fontFamily),
            italic: computed.fontStyle === 'italic',
            underline: computed.textDecoration.includes('underline')
          }
        });
      }

      processed.add(el);
    });

    return { background, elements, placeholders, errors };
  });
}

async function html2pptx(htmlFile, pres, options = {}) {
  const {
    tmpDir = process.env.TMPDIR || '/tmp',
    slide = null
  } = options;

  try {
    // Use Chrome on macOS, default Chromium on Unix
    const launchOptions = { env: { TMPDIR: tmpDir } };
    if (process.platform === 'darwin') {
      launchOptions.channel = 'chrome';
    }

    const browser = await chromium.launch(launchOptions);

    let bodyDimensions;
    let slideData;

    const filePath = path.isAbsolute(htmlFile) ? htmlFile : path.join(process.cwd(), htmlFile);
    const validationErrors = [];

    try {
      const page = await browser.newPage();
      page.on('console', (msg) => {
        // Log the message text to your test runner's console
        console.log(`Browser console: ${msg.text()}`);
      });

      await page.goto(`file://${filePath}`);

      bodyDimensions = await getBodyDimensions(page);

      await page.setViewportSize({
        width: Math.round(bodyDimensions.width),
        height: Math.round(bodyDimensions.height)
      });

      slideData = await extractSlideData(page);
    } finally {
      await browser.close();
    }

    // Collect all validation errors
    if (bodyDimensions.errors && bodyDimensions.errors.length > 0) {
      validationErrors.push(...bodyDimensions.errors);
    }

    const dimensionErrors = validateDimensions(bodyDimensions, pres);
    if (dimensionErrors.length > 0) {
      validationErrors.push(...dimensionErrors);
    }

    const textBoxPositionErrors = validateTextBoxPosition(slideData, bodyDimensions);
    if (textBoxPositionErrors.length > 0) {
      validationErrors.push(...textBoxPositionErrors);
    }

    if (slideData.errors && slideData.errors.length > 0) {
      validationErrors.push(...slideData.errors);
    }

    // Throw all errors at once if any exist
    if (validationErrors.length > 0) {
      const errorMessage = validationErrors.length === 1
        ? validationErrors[0]
        : `Multiple validation errors found:\n${validationErrors.map((e, i) => `  ${i + 1}. ${e}`).join('\n')}`;
      throw new Error(errorMessage);
    }

    const targetSlide = slide || pres.addSlide();

    await addBackground(slideData, targetSlide, tmpDir);
    addElements(slideData, targetSlide, pres);

    return { slide: targetSlide, placeholders: slideData.placeholders };
  } catch (error) {
    if (!error.message.startsWith(htmlFile)) {
      throw new Error(`${htmlFile}: ${error.message}`);
    }
    throw error;
  }
}

module.exports = html2pptx;
</file>

<file path="slides-new/package.json">
{
  "name": "slides-new",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "build": "node build.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "playwright": "^1.56.1",
    "pptxgenjs": "^4.0.1",
    "sharp": "^0.34.4"
  }
}
</file>

<file path="slides-new/README.md">
# Agentic AI Agent Talk Slides

HTML-to-PowerPoint pipeline for the "Agentic AI for Reproducible Language Science" talk.

## Rebuilding

```bash
cd slides-new
npm install
npx playwright install chromium   # first run only
npm run build
```

The build script converts the HTML slides in `html/` using the `html2pptx` pipeline and writes `Agentic-AI-Agent-Talk.pptx` in this directory.
</file>

<file path="talk/outline.md">
```qmd
---
title: "Agentic AI for reproducible language science: from prompt to pipeline"
format:
  pptx:
    reference-doc: template.potx
execute:
  eval: false
toc: false
---

# Section Header: Why agents now
::: {.notes}
Timing: 0:00–1:30. Set the capability frame and the “Ask → Plan → Do → Record” loop.
:::

---

# From chat to agents
::: {.notes}
Timing: 1:30–3:00. Define agents as planner, tool‑caller, executor, reporter.
:::
- Agents plan multi‑step work.
- They call external tools.
- They run code and scripts.
- They record actions and results.
- Capability expands; speed increases.
![Simple agent loop schematic (non‑generative)](placeholder.png)

---

# What you will learn today
::: {.notes}
Timing: 3:00–4:00. Emphasise that it is R‑focused but portable.
:::
- Where agents add capability.
- Pragmatic pitfalls and mitigations.
- Run a containerised R workflow.
- Use GitHub for visible review.

---

# Section Header: Landscape and access
::: {.notes}
Timing: 4:00–4:20. Name systems briefly; no deep dive.
:::
---

# Systems you may encounter
::: {.notes}
Timing: 4:20–5:30. Keep brand‑agnostic; students use what is available.
:::
- Claude Code (web/IDE).
- Cursor (IDE agent mode).
- Coding agents in editors.
- Choose what your lab supports.
![Claude Code, Cursor, editor logos (insert non‑generative logos)](placeholder.png)

---

# China‑aware options (one slide)
::: {.notes}
Timing: 5:30–6:30. Mention without prices; institutions vary.
:::
- Qwen models (AliCloud).
- Kimi (Moonshot AI).
- GLM (Zhipu AI).
- ERNIE, Hunyuan, Doubao.
![Provider logos grid (insert non‑generative logos)](placeholder.png)

---

# Thinking about costs
::: {.notes}
Timing: 6:30–8:00. Teach patterns, not price lists.
:::
- Three patterns: subscription, tokens, editor.
- Iterations drive spend.
- Keep prompts short.
- Prefer small models for drafts.
![Token cost formula schematic (non‑generative)](placeholder.png)

---

# Section Header: Promise and pitfalls
::: {.notes}
Timing: 8:00–8:15. Shift from tools to practice.
:::
---

# What gets better now
::: {.notes}
Timing: 8:15–9:30. Capability and provenance, not hype.
:::
- Attempt larger tasks.
- Explore alternatives quickly.
- Faster first drafts.
- Traceable, recorded changes.

---

# Pitfalls you will meet
::: {.notes}
Timing: 9:30–11:00. Keep pragmatic and actionable.
:::
- Overreach beyond expertise.
- Skill drift if you stop reading.
- Cost creep from many runs.
- Mitigate: small tasks, tests, review.

---

# Section Header: Methods tutorial (R‑focused)
::: {.notes}
Timing: 11:00–11:15. From ideas to one runnable pipeline.
:::
---

# Why containers help agents
::: {.notes}
Timing: 11:15–12:30. Agents arrive “cold”; containers standardise starts.
:::
- Predictable start each run.
- Self‑documenting projects win.
- If a stranger can run it…
- …an agent can run it.
![Container concept icon (non‑generative)](placeholder.png)

---

# Repo skeleton (demo)
::: {.notes}
Timing: 12:30–13:30. Show structure you will actually run.
:::
- README with quickstart.
- Makefile orchestration.
- R scripts for steps.
- Raw, processed, results folders.
- Wrapper script to run R.
![Repository tree schematic (non‑generative)](placeholder.png)

---

# One pipeline, end‑to‑end
::: {.notes}
Timing: 13:30–14:45. Makefile first; upgrade later if needed.
:::
- Simple Makefile rules.
- Deterministic script runs.
- Diffable result files.
- Upgrade path exists later.

---

# Section Header: Example — lexical decision (Option A)
::: {.notes}
Timing: 14:45–15:00. Language‑science example; tiny lawful slices.
:::
---

# Task and data (tiny slices)
::: {.notes}
Timing: 15:00–16:00. Keep datasets small; ship locally.
:::
- Behaviour: lexical decision RTs.
- Predictors: frequency, strokes.
- Join SCLP with CLD rows.
- Aim: small, fast, illustrative.
![Lexical decision schematic (non‑generative)](placeholder.png)

---

# Demo: what you will run
::: {.notes}
Timing: 16:00–17:00. Prepare a fallback recording.
:::
- Clone the repo.
- Run `make` once.
- View `metrics.yml`.
- Keep a short screencast.

---

# Live steps (5–6 minutes)
::: {.notes}
Timing: 17:00–23:00. Small change + re‑run + visible diff.
:::
- Run `make` to baseline.
- Agent adds one predictor.
- Re‑run `make` deterministically.
- Show diff in `metrics.yml`.
- Commit and open a PR.

---

# Interactive vs script‑based
::: {.notes}
Timing: 23:00–24:30. Draft interactively, execute by script.
:::
- Draft with an agent.
- Execute via scripts.
- Scripts beat ad‑hoc REPL.
- Reproducibility first.

---

# Section Header: GitHub basics
::: {.notes}
Timing: 24:30–24:45. Light‑touch process; keep humans engaged.
:::
---

# Keep the human in the loop
::: {.notes}
Timing: 24:45–26:15. One screenshot of a PR with a small diff.
:::
- Branch → PR → review.
- Scoped commits with notes.
- Small, reviewable changes.
- Merge with confidence.
![PR with small YAML diff (non‑generative)](placeholder.png)

---

# End‑to‑end reporting
::: {.notes}
Timing: 26:15–27:45. Manuscript pulls numbers from results tables.
:::
- Results as CSV/YAML.
- Manuscript reads tables.
- Changes stay transparent.
![Manuscript numbers from tables schematic (non‑generative)](placeholder.png)

---

# Section Header: Wrap‑up and questions
::: {.notes}
Timing: 27:45–28:00. Leave time buffer for Q&A up to 40:00.
:::
---

# Take‑home
::: {.notes}
Timing: 28:00–29:00. Close with four rules of thumb.
:::
- Agents expand capability.
- Structure keeps them honest.
- Container + Makefile + scripts.
- GitHub review for trust.

---

# Q&A
::: {.notes}
Timing: 29:00–40:00. Keep a slide visible with repo URL and a QR code placeholder.
:::
![Repo URL / QR code placeholder (non‑generative)](placeholder.png)
```
</file>

<file path="talk/talk-outline-only.md">
AGENT TALK

# Agentic AI for Reproducible Language Science: From Prompt to Pipeline

Shane Lindsay  
s.lindsay@hull.ac.uk
University of Hull  
https://github.com/shanelindsay/agentic-r/

# Agenda

- Why now (spoiler: they finally work)
- What is an agent
- Demo: agents and reproducible research patterns
- Practical patterns you can steal

# Pre-requisites

Assume you have used LLM chatbots, for example ChatGPT, ==探索未至之境==  
Assume knowledge of R (applies to Python and other tools too)

# Why agents now

- LLM models are now smart enough for multi-step, tool-using tasks
- They are cheap enough to be practical for students and labs
- Agents are accessible
- The technology is useful for everyday research work

**Provocation**: By the end of 2025, no one will ever need to code or use a GUI (like SPSS) again

# What is an agent

- General purpose LLM that lives inside a computer
- Read and write access to the file system, with access to bash or PowerShell
- Whatever you can do, it can do, with guardrails and approvals
- Can work autonomously for typically less than 20 minutes
- Search the web, write code, execute it, write it up
- Full end to end scientific process  
  - Today focused on analyses

# Costs

- One knob: fast and rough versus slow and smart
- Daily heavy use: $200 per month
- Moderate use: $100 per month
- Light use: $20 per month
- Free tiers exist

# Examples

- US: Codex (OpenAI), Claude Code (Anthropic), Gemini (Google), Cursor, Copilot (Microsoft)
- China: Kimi K2, Qwen 3, GLM 4.5
- Currently: OpenAI Codex is smartest, Claude Code 4.5 second, GLM or K2 best for cost

# Promise of agents

- Increase speed
- Increase capability

# Perils of agents

- Errors
- Loss of control and responsibility
- Atrophy of skills
- Technical demands and complexity (tech debt)

# Using agents

- Think of an agent as a new lab member arriving cold to your research project
- Very keen, very fast, very smart, sometimes wise, sometimes also wrong
- Agents work best when projects are structured, documented and runnable
- Structure encourages consistent patterns in your workflows

# Why reproducible research

- Verify findings, others can validate your results
- Reduce bias through transparency in methods
- Catch errors, community review improves quality
- Preserve knowledge beyond individual researchers
- Increasingly required by funding agencies and journals

# Reproducible research and agentic AI are best friends

- Research codebase lifecycle: plan → execute → review → share → re-run
- Reproducibility means others, including agents, can repeat the same steps and get the same artefacts
- Agents support reproducibility when outputs are scripted, logged and text based

# Coding patterns and how agents interact

- beginner: Monolithic 1000 line script: quick start, fragile for change, sprawl, hard to understand and debug
- intermediate: Numbered scripts: clearer workflow, smaller functional units
- pro: Makefile orchestrated scripts: targets, explicit dependencies, deterministic runs

**Goal**: press a button, raw data transformed directly to numbers in a manuscript

# Containers and predictability

- Containers are cloud based Unix environments that can be spun up and thrown away
- Agents are stateless across sessions, containers provide a predictable starting point
- Running agents in container makes it safer
- If a stranger can run the repo from the documentation, an agent can too

# GitHub

- GitHub provides version tracking
- Protect work from being overwritten, history is always saved
- Agents can use it via bash, you can interact in an IDE or on web
- You can monitor and approve any changes with pull requests

# shanelindsay/agentic-r GitHub repo

- `AGENTS.md`: how the agent should work in this repo - the "handbook"
- `dev/run-in-env.sh`: get R working using micromamba
- `environment.yml`: R version and packages to use (numbered, reproducible)
- `makefile` - recipe of what scripts to run in which order
- Agents are told to use the wrapper to run scripts

# Workflow

- Makefile and two small R scripts (`01_prepare.R`, `02_model.R`)
- `data/raw`, `data/processed`, `results/metrics.yml`
- Results feed into quarto report

# Example: Lexical Decision in Chinese
- Wang, Y., Wang, Y., Chen, Q., & Keuleers, E. (2025). Simplified Chinese lexicon project: A lexical decision database with 8,105 characters and 4,864 pseudocharacters. Behavior Research Methods, 57, 206. https://doi.org/10.3758/s13428-025-02701-7  

- Sun, C. C., Hendrix, P., Ma, J. Q., & Baayen, R. H. (2018). Chinese Lexical Database (CLD): A large‑scale lexical database for simplified Chinese. Behavior Research Methods, 50(5), 2606–2629. https://doi.org/10.3758/s13428-018-1038-3  

# Example: Lexical Decision in Chinese

- Baseline: run the pipeline once to produce `metrics.yml`
- lexical decision RT with lexical predictors

# Agent demo: Builder

- Agent prompt: add one predictor and rerun report 
- Agent runs pipeline with wrapper and Makefile

# End to end reporting

- Manuscript or Quarto report reads values from `results/*`
- This keeps numbers traceable and updates transparent

# Agent demo: Github Pull Request Review

- Second agent reads the PR diff and writes a review
- Human reviews the agent review and approves or requests changes
- Loop...

# Agent patterns to copy

- Builder: proposes and edits code
- Checker: audits diffs and outputs
- Critic (optional): proposes tests or diagnostics
- Humans remain the final approvers

# Where to start

- Pick one stage, cleaning or modelling or reporting, and start small
- Keep tasks atomic
- Measure time saved against review effort

# Practical tips

- Short, explicit prompts, give file paths and desired outputs
- Make outputs diffable (CSV or YAML), keep raw data read only

# Take-home

- Agents expand what you can do
- You become a project manager rather than coder - different skill set, but still techical skills needed
- Structure, container plus Makefile plus scripts plus PRs
- Start small, review everything, iterate responsibly


# Q and A

s.lindsay@hull.ac.uk
https://github.com/shanelindsay/agentic-r/
</file>

</files>
